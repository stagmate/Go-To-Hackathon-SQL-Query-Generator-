<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gojek AI SQL Query Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phosphor-icons/1.4.2/phosphor-icons.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* ... (all your other CSS styles remain the same) ... */
        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #10b981;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen antialiased">

    <div class="w-full bg-white shadow-md">
        <div class="container mx-auto max-w-5xl px-4 py-4">
            <h1 class="text-2xl font-bold text-gray-900">
                <span class="text-green-600">Gojek</span> AI SQL Query Generator
            </h1>
            <p class="text-gray-600">Ask a question, and the AI will generate the correct query.</p>
        </div>
    </div>

    <div class="container mx-auto max-w-5xl px-4 py-8">
        
        <div class="mb-6">
            <label for="search-query" class="block text-sm font-medium text-gray-700 mb-2">Ask your question</label>
            <div class="flex items-center gap-2">
                <input type="text" id="search-query" 
                       placeholder="e.g., 'average orders for GoRide in Jakarta last week'"
                       class="w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-green-500 focus:border-green-500 text-lg">
                <button id="generate-sql-btn" class="bg-green-600 text-white font-semibold py-3 px-5 rounded-lg shadow-md hover:bg-green-700 transition duration-200 flex items-center justify-center gap-2">
                    <i class="ph-sparkle text-xl"></i>
                    <span id="generate-btn-text">Generate</span>
                    <div id="loading-spinner" class="spinner hidden"></div>
                </button>
            </div>
        </div>

        <div id="error-message" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-6" role="alert">
            <strong class="font-bold">Error: </strong>
            <span class="block sm:inline" id="error-text"></span>
        </div>

        <div id="sql-output-section" class="bg-gray-900 p-6 rounded-lg shadow-md relative hidden">
            <h2 class="text-xl font-bold text-white mb-4">Generated SQL Query</h2>
            <button id="copy-sql-btn" title="Copy to Clipboard" class="absolute top-4 right-4 bg-gray-700 text-gray-300 hover:bg-gray-600 hover:text-white p-2 rounded-lg transition duration-200">
                <i class="ph-clipboard-text text-xl"></i>
            </button>
            <pre><code id="sql-output" class="text-green-300 whitespace-pre-wrap break-all">...</code></pre>
            <div id="copy-success" class="absolute top-14 right-4 bg-green-500 text-white text-xs font-semibold px-2 py-1 rounded shadow-md hidden">
                Copied!
            </div>
        </div>
    </div>

    <script>
        // --- THE METRIC REGISTRY ---
        // This stays exactly the same
        const METRIC_REGISTRY = [
            // ... (all your metric objects remain the same) ...
             {
                id: 'avg_daily_orders',
                name: 'Average Daily Orders',
                // ...
            },
            {
                id: 'total_gtv',
                name: 'Total Earnings (GTV)',
                // ...
            },
            {
                id: 'daily_active_drivers',
                name: 'Daily Active Drivers (Avg)',
                // ...
            },
            {
                id: 'caretech_ratings',
                name: 'Average CareTech Rating',
                // ...
            }
        ];

        // --- DOM Elements ---
        // These stay exactly the same
        const searchQueryInput = document.getElementById('search-query');
        const generateSqlBtn = document.getElementById('generate-sql-btn');
        // ... (all other DOM elements) ...
        const copySuccessEl = document.getElementById('copy-success');


        // --- Helper Functions ---
        // All helper functions (setLoading, showError, hideError, getDates, copyToClipboard)
        // stay exactly the same.
        
        function setLoading(isLoading) { /* ... */ }
        function showError(message) { /* ... */ }
        function hideError() { /* ... */ }
        function getDates(startDate, endDate) { /* ... */ }
        function copyToClipboard(text) { /* ... */ }


        // --- AI & Generation Logic ---

        /**
         * Creates the system prompt for the AI.
         * This stays the same.
         */
        function createSystemPrompt() {
            const today = new Date().toISOString().split('T')[0];
            const contextMetrics = METRIC_REGISTRY.map(m => ({
                id: m.id,
                name: m.name,
                description: m.description,
                keywords: m.keywords
            }));

            return `You are a Gojek SQL Query Bot. Your task is to analyze a user's natural language question and map it to a pre-defined metric from a registry. You MUST return a JSON object that identifies the correct metric and extracts the required parameters.

**Metric Registry (Context):**
${JSON.stringify(contextMetrics, null, 2)}

**Instructions:**
1.  Read the user's query.
2.  Compare the query to the \`name\`, \`description\`, and \`keywords\` in the Metric Registry.
3.  Select the *single best* matching \`id\`. If no metric is a good match, return 'none' for the metricId.
4.  Extract the following parameters from the user's query:
    * \`startDate\` & \`endDate\`: Infer from relative terms ('last week', 'today', 'past 30 days'). Today is ${today}. If no date is mentioned, return 'NOT_SPECIFIED' for both.
    * \`product\`: (e.g., 'GoRide', 'GoCar', 'CareTech'). If not mentioned or is "all", return 'All'.
    * \`region\`: (e.g., 'Jakarta', 'Bandung'). If not mentioned or is "all", return 'All'.
5.  You MUST return a JSON object matching the specified schema.
`;
        }
        
        /**
         * The AI_RESPONSE_SCHEMA object is GONE from this file.
         * It is now defined in the backend function.
         */
        

        /**
         * MODIFIED FUNCTION
         * Calls YOUR OWN BACKEND to interpret the user's query.
         */
        async function getAiInterpretation(userQuery, systemPrompt) {
            
            // This is the new API call to your own backend proxy.
            // It assumes your backend function is at '/api/generate-sql'
            const response = await fetch('/api/generate-sql', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ userQuery, systemPrompt }) // Send the query to your server
            });

            if (!response.ok) {
                const errorResult = await response.json();
                // Show the error from the backend
                throw new Error(errorResult.error || 'Failed to fetch from backend proxy');
            }

            // Return the JSON response from your server
            return await response.json();
        }


        /**
         * Main handler for the "Generate SQL" button click.
         * This stays exactly the same.
         */
        async function handleGenerateSql() {
            hideError();
            const userQuery = searchQueryInput.value;
            if (!userQuery.trim()) {
                showError('Please ask a question.');
                return;
            }

            setLoading(true);
            sqlOutputSection.classList.add('hidden');

            try {
                const systemPrompt = createSystemPrompt();
                // This function now calls your backend, but the rest of the logic
                // in this handler doesn't need to change!
                const aiResponse = await getAiInterpretation(userQuery, systemPrompt);

                if (!aiResponse || aiResponse.metricId === 'none') {
                    showError("Sorry, I couldn't find a matching metric for your question. Please try rephrasing.");
                    setLoading(false);
                    return;
                }
                
                // Find the metric in our *local* registry
                const metric = METRIC_REGISTRY.find(m => m.id === aiResponse.metricId);
                
                if (!metric) {
                    showError(`AI returned an invalid metric ID: ${aiResponse.metricId}.`);
                    setLoading(false);
                    return;
                }

                // AI provides the parameters, our template builds the SQL
                const sqlQuery = metric.sqlTemplate(aiResponse);
                
                // Trim and display
                sqlOutputEl.textContent = sqlQuery.trim();
                sqlOutputSection.classList.remove('hidden');
                
                // Scroll to the output
                sqlOutputSection.scrollIntoView({ behavior: 'smooth', block: 'end' });

            } catch (error) {
                console.error('Error during AI generation:', error);
                // The error message will now come from your backend
                showError(`Generation failed: ${error.message}. Please check console.`);
            } finally {
                setLoading(false);
            }
        }
        
        // --- Attach Event Listeners ---
        // These stay exactly the same.
        generateSqlBtn.addEventListener('click', handleGenerateSql);
        copySqlBtn.addEventListener('click', () => {
            copyToClipboard(sqlOutputEl.textContent);
        });
        // Allow pressing Enter to generate
        searchQueryInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent form submission
                handleGenerateSql();
            }
        });

    </script>

</body>
</html>
